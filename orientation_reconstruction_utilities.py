import numpy as np
import math
import statistics

# If we are given a diagonal matrix D = (d1, ..., d_n) and want to compute the eigenvalues 
# of D + u u^T, these are up to deflation of trivial eigenvalues given by the solutions of the 
# so-called secular equation, given by
# 1 + \sum_{i = 1}^n u_i^2 / (d_i + \lambda) = 0
# This function computes this secular function (with a reflected argument) in the special
# case of n = 2. Although this function does not need it, we implicitly assume d2 <= d1.
def secular_function(u1, d1, u2, d2):
  def f(x):
    return pow(u1, 2) / (d1 - x) + pow(u2, 2) / (d2 - x)
  return f

# compute the inverse of the above mentioned secular function on the interval (-\infty, d2)
def inverse_secular_function(u1, d1, u2, d2):
  def f(x):
    p = (1/x) * (pow(u1, 2) + pow(u2, 2)) - d1 - d2
    q = d1 * d2 - (1/x) * (pow(u1, 2) * d2 + pow(u2, 2) * d1)
    return -0.5 * p - math.sqrt(pow(p/2, 2) - q)
  return f


# compute the (descending) sorted eigenvalue decomposition of a 
# square matrix
# params : 
#           - mat : square matrix
# returns :
#           - tuple (vals, vecs), where vals contains the eigenvalues and the columns of vecs
#             contain the eigenvalues
def sorted_eigendecomposition(mat):
  vals, vecs = np.linalg.eig(mat)
  permutation = np.argsort(vals)[::-1]
  vals = vals[permutation]
  vecs = vecs[:, permutation]
  return (vals, vecs)

# compute the mean second moment matrix R (called covariance matrix in the Sekihara book)
# generated by a single source and a given noise level
# params : 
#         - noise_covariance  : n x n matrix
#         - lead_field_matrix : n x dim matrix, where the columns are the lead field vectors for the unit vectors
#         - orientation       : vector with 3 entries, describes the orientation
#         - source_variance   : scalar, gives the variance of the neural activity
def noisy_single_source_covariance_matrix(noise_covariance, lead_field_matrix, orientation, source_variance = 1.0):
  lead_field_vector = lead_field_matrix @ orientation
  number_of_sensors = len(lead_field_matrix)
  rank_one_matrix = source_variance * lead_field_vector.reshape(number_of_sensors, 1) @ lead_field_vector.reshape(1, number_of_sensors)
  return rank_one_matrix + noise_covariance

# params : 
#          -A, B : n x n symmetric positive definite matrices
# Under these assumptions, there is a basis v_1, ..., v_n consisting of so called generalized eigenvectors, which are solutions of the equation
#       A x = lambda * B * x
# Such a lambda is called a generalized eigenvalue, and under the above assumptions these are all > 0. 
# This function computes a generalized eigenvector to the smallest generalized eigenvalue of the given problem
# returns :
#         - vector with n entries, which is a generalized eigenvector of the smallest generalized eigenvalue of Ax = lambda Bx. A vector with unit norm is returned.
def smallest_generalized_eigenvector(A, B):
  (eigenvals, eigenvecs) = sorted_eigendecomposition(np.linalg.inv(B) @ A)
  smallest_eigenvec = eigenvecs[:, -1]
  smallest_eigenvec = smallest_eigenvec / np.linalg.norm(smallest_eigenvec)
  return smallest_eigenvec


# compute the optimum orientation using the unit gain beamformer, i.e. the direction maximizing the corresponding virtual sensor power
# params :
#           - covariance_matrix : second moment matrix as defined in the Sekihara book
#           - lead_field_matrix : n x dim matrix, where the columns are the lead field vectors for the unit vectors
def unit_gain_orientation(covariance_matrix, lead_field_matrix):
  A = lead_field_matrix.T @ np.linalg.pinv(covariance_matrix) @ lead_field_matrix
  size = lead_field_matrix.shape[1]
  B = np.eye(size)
  return smallest_generalized_eigenvector(A, B)

# compute the optimum orientation using the array gain beamformer, i.e. the direction maximizing the corresponding virtual sensor power
# params :
#           - covariance_matrix : second moment matrix as defined in the Sekihara book
#           - lead_field_matrix : n x dim matrix, where the columns are the lead field vectors for the unit vectors
def array_gain_orientation(covariance_matrix, lead_field_matrix):
  A = lead_field_matrix.T @ np.linalg.pinv(covariance_matrix) @ lead_field_matrix
  B = lead_field_matrix.T @ lead_field_matrix
  return smallest_generalized_eigenvector(A, B)

# compute the optimum orientation using the unit noise gain beamformer, i.e. the direction maximizing the corresponding virtual sensor power
# params :
#           - covariance_matrix : second moment matrix as defined in the Sekihara book
#           - lead_field_matrix : n x dim matrix, where the columns are the lead field vectors for the unit vectors
def unit_noise_gain_orientation(covariance_matrix, lead_field_matrix):
  A = lead_field_matrix.T @ np.linalg.pinv(covariance_matrix) @ np.linalg.pinv(covariance_matrix) @ lead_field_matrix
  B = lead_field_matrix.T @ np.linalg.pinv(covariance_matrix) @ lead_field_matrix
  return smallest_generalized_eigenvector(A, B)

# compute the angle (in degrees) between two vectors v and w
def angle(v, w):
  return 360 * (1/(2 * np.pi)) * np.arccos(np.inner(v, w) / (np.linalg.norm(v) * np.linalg.norm(w)))

#####################################
# reconstruction experiments
#####################################
def source_magnitude(sample_index, fq, fs):
  return np.sin(2 * np.pi * fq * sample_index / fs)

# EEG reconstruction experiment
# Generate a vector of samples of 
# d(t) = q(t) * L @ ori + n(t),
# where n(t) is gaussian noise. This is then used to compute the sample covariance matrix,
# which we then use to perform the orientation reconstruction
def eeg_reconstruction_experiment(true_orientation, full_lead_field, noise_level, fq, fs, nr_samples, regularization):
  
  # initialize rng
  rng = np.random.default_rng()
  
  nr_sensors = full_lead_field.shape[0]
  normed_lf = full_lead_field @ true_orientation
  lf_norm = np.linalg.norm(normed_lf)
  normed_lf /= lf_norm
  
  # set noise parameters
  noise_mean = np.zeros(nr_sensors)
  noise_covariance = math.pow(noise_level, 2) * np.identity(nr_sensors)
  
  # generate noise samples in one go
  noise_samples = rng.multivariate_normal(noise_mean, noise_covariance, nr_samples)
  
  # generate sample covariance matrix  
  time_course = np.array([source_magnitude(i, fq, fs) for i in range(nr_samples)]).reshape((nr_samples, 1))
  data_matrix = np.repeat(time_course, nr_sensors, axis = 1) * np.tile(normed_lf, (nr_samples, 1)) + noise_samples
  covariance_matrix = (data_matrix.T @ data_matrix) / nr_samples
  covariance_matrix += regularization * (np.trace(covariance_matrix) / nr_sensors) * np.identity(nr_sensors)
  
  # reconstruct orientation using sample covariance matrix
  ug_ori = unit_gain_orientation(covariance_matrix, full_lead_field)
  ag_ori = array_gain_orientation(covariance_matrix, full_lead_field)
  ung_ori = unit_noise_gain_orientation(covariance_matrix, full_lead_field)
  
  # potentially flip orientation
  if np.inner(ug_ori, true_orientation) < 0:
    ug_ori *= -1
  if np.inner(ag_ori, true_orientation) < 0:
    ag_ori *= -1
  if np.inner(ung_ori, true_orientation) < 0:
    ung_ori *= -1
  
  # compute some statistics
  expected_covariance_matrix = noisy_single_source_covariance_matrix(noise_covariance, full_lead_field, true_orientation, 0.5 * (1/(pow(lf_norm, 2))))
  rel_diff_cov = np.linalg.norm(covariance_matrix - expected_covariance_matrix) / np.linalg.norm(expected_covariance_matrix)
  
  angle_ug = angle(true_orientation, ug_ori)
  angle_ag = angle(true_orientation, ag_ori)
  angle_ung = angle(true_orientation, ung_ori)
  
  return {'ug_ori' : ug_ori, 'ag_ori' :ag_ori, 'ung_ori' : ung_ori, 'ug_angle_diff' : angle_ug, 'ag_angle_diff' : angle_ag, 'ung_angle_diff' : angle_ung, 'covariance_matrix' : covariance_matrix}

# MEG reconstruction experiment
# Generate a vector of samples of 
# d(t) = q(t) * L @ ori + n(t),
# where n(t) is gaussian noise. This is then used to compute the sample covariance matrix,
# which we then use to perform the orientation reconstruction
def meg_reconstruction_experiment(true_orientation, full_lead_field, noise_level, fq, fs, nr_samples, regularization):
  
  # initialize rng
  rng = np.random.default_rng()
  
  nr_sensors = full_lead_field.shape[0]
  normed_lf = full_lead_field @ true_orientation
  lf_norm = np.linalg.norm(normed_lf)
  normed_lf /= lf_norm
  
  # set noise parameters
  noise_mean = np.zeros(nr_sensors)
  noise_covariance = math.pow(noise_level, 2) * np.identity(nr_sensors)
  
  # generate noise samples in one go
  noise_samples = rng.multivariate_normal(noise_mean, noise_covariance, nr_samples)
  
  # generate sample covariance matrix  
  time_course = np.array([source_magnitude(i, fq, fs) for i in range(nr_samples)]).reshape((nr_samples, 1))
  data_matrix = np.repeat(time_course, nr_sensors, axis = 1) * np.tile(normed_lf, (nr_samples, 1)) + noise_samples
  covariance_matrix = (data_matrix.T @ data_matrix) / nr_samples
  covariance_matrix += regularization * (np.trace(covariance_matrix) / nr_sensors) * np.identity(nr_sensors)
  
  # reduce leadfield
  U, S, V_transposed = np.linalg.svd(full_lead_field)
  reduced_lead_field = full_lead_field @ (V_transposed.T)[:, :2]
  
  # reconstruct orientation using sample covariance matrix
  ug_ori = unit_gain_orientation(covariance_matrix, reduced_lead_field)
  ag_ori = array_gain_orientation(covariance_matrix, reduced_lead_field)
  ung_ori = unit_noise_gain_orientation(covariance_matrix, reduced_lead_field)
  
  # potentially flip orientation
  if np.inner(V_transposed.T[:, 0:2] @ ug_ori, true_orientation) < 0:
    ug_ori *= -1
  if np.inner(V_transposed.T[:, 0:2] @ ag_ori, true_orientation) < 0:
    ag_ori *= -1
  if np.inner(V_transposed.T[:, 0:2] @ ung_ori, true_orientation) < 0:
    ung_ori *= -1
  
  # compute some statistics
  true_orientation_tangential = V_transposed[0:2, :] @ true_orientation
  true_orientation_tangential /= np.linalg.norm(true_orientation_tangential)
  
  expected_covariance_matrix = noisy_single_source_covariance_matrix(noise_covariance, full_lead_field, true_orientation, 0.5 * (1/(pow(lf_norm, 2))))
  rel_diff_cov = np.linalg.norm(covariance_matrix - expected_covariance_matrix) / np.linalg.norm(expected_covariance_matrix)
  
  angle_ug = angle(true_orientation_tangential, ug_ori)
  angle_ag = angle(true_orientation_tangential, ag_ori)
  angle_ung = angle(true_orientation_tangential, ung_ori)
  
  return {'ug_ori' : ug_ori, 'ag_ori' :ag_ori, 'ung_ori' : ung_ori, 'ug_angle_diff' : angle_ug, 'ag_angle_diff' : angle_ag, 'ung_angle_diff' : angle_ung, 'covariance_matrix' : covariance_matrix}

# EMEG reconstruction experiment
# Generate a vector of samples of
# d_EEG(t) = q(t) * L_EEG @ ori + n_EEG(t)
# and
# d_MEG(t) = q(t) * L_MEG @ ori + n_MEG(t)
# where n_EEG, n_MEG is gaussian noise, and L_EEG, L_MEG are the EEG and MEG leadfields, and
# q(t) is the source strength
#   params:
#     - true_orientation        :   3 entry array describing the true source orientation
#     - full_eeg_leadfield      :   n_E x 3 array, where n_E is the number of EEG sensors
#     - full_meg_leadfield      :   n_M x 3 array, where n_M is the number of MEG sensors
#     - eeg_noise_level         :   scalar, describing the standard deviation of the EEG noise
#     - meg_noise_level         :   scalar, describing the standard deviation of the MEG noise
#     - fq                      :   scalar, describing the source oscillation frequency
#     - fs                      :   scalar, describing the sampling frequency
#     - regularization          :   scalar, add regularization * (trace(C) / nr_rows_C) * I to the covariance matrices
#     - use_nonuniform_noise    :   bool, describing ifa  noise covariance of the form sigma * I
#                                   is used or if a random positive definite matrix is used
#   returns :
#     - dictionary containing the reconstructed orientations for the different beamformer approaches, the reconstruction errors, and the sample covariance matrices
def emeg_reconstruction_experiment(true_orientation, full_eeg_leadfield, full_meg_leadfield, eeg_noise_level, meg_noise_level, fq, fs, nr_samples, regularization):
  
  # initialize rng
  rng = np.random.default_rng()
  
  nr_eeg_sensors = full_eeg_leadfield.shape[0]
  nr_meg_sensors = full_meg_leadfield.shape[0]
  
  normed_eeg_lf = full_eeg_leadfield @ true_orientation
  eeg_lf_norm = np.linalg.norm(normed_eeg_lf)
  normed_eeg_lf /= eeg_lf_norm
  
  normed_meg_lf = full_meg_leadfield @ true_orientation
  meg_lf_norm = np.linalg.norm(normed_meg_lf)
  normed_meg_lf /= meg_lf_norm
  
  ##############
  # construct covariance matrices
  ##############
  
  # construct noise parameters
  eeg_noise_mean = np.zeros(nr_eeg_sensors)
  meg_noise_mean = np.zeros(nr_meg_sensors)
  eeg_noise_covariance = math.pow(eeg_noise_level, 2) * np.identity(nr_eeg_sensors)
  meg_noise_covariance = math.pow(meg_noise_level, 2) * np.identity(nr_meg_sensors)
  
  # generate all noise samples in one go
  eeg_noise_samples = rng.multivariate_normal(eeg_noise_mean, eeg_noise_covariance, nr_samples)
  meg_noise_samples = rng.multivariate_normal(meg_noise_mean, meg_noise_covariance, nr_samples)
  
  # generate sample covariance matrices
  time_course = np.array([source_magnitude(i, fq, fs) for i in range(nr_samples)]).reshape((nr_samples, 1))
  
  eeg_data_matrix = np.repeat(time_course, nr_eeg_sensors, axis = 1) * np.tile(normed_eeg_lf, (nr_samples, 1)) + eeg_noise_samples
  eeg_covariance_matrix = (eeg_data_matrix.T @ eeg_data_matrix) / nr_samples
  eeg_covariance_matrix += regularization * (np.trace(eeg_covariance_matrix) / nr_eeg_sensors) * np.identity(nr_eeg_sensors)
  
  meg_data_matrix = np.repeat(time_course, nr_meg_sensors, axis = 1) * np.tile(normed_meg_lf, (nr_samples, 1)) + meg_noise_samples
  meg_covariance_matrix = (meg_data_matrix.T @ meg_data_matrix) / nr_samples
  meg_covariance_matrix += regularization * (np.trace(meg_covariance_matrix) / nr_meg_sensors) * np.identity(nr_meg_sensors)
  
  ##############
  # perform orientation reconstruction
  ##############
  
  ######
  #EEG
  ######
  eeg_ug_ori = unit_gain_orientation(eeg_covariance_matrix, full_eeg_leadfield)
  eeg_ag_ori = array_gain_orientation(eeg_covariance_matrix, full_eeg_leadfield)
  eeg_ung_ori = unit_noise_gain_orientation(eeg_covariance_matrix, full_eeg_leadfield)
  
  # potentially flip orientation
  if np.inner(eeg_ug_ori, true_orientation) < 0:
    eeg_ug_ori *= -1
  if np.inner(eeg_ag_ori, true_orientation) < 0:
    eeg_ag_ori *= -1
  if np.inner(eeg_ung_ori, true_orientation) < 0:
    eeg_ung_ori *= -1
  
  eeg_ug_angle = angle(true_orientation, eeg_ug_ori)
  eeg_ag_angle = angle(true_orientation, eeg_ag_ori)
  eeg_ung_angle = angle(true_orientation, eeg_ung_ori)
  
  ######
  #MEG
  ######
  U, S, V_transposed = np.linalg.svd(full_meg_leadfield)
  reduced_meg_leadfield = full_meg_leadfield @ (V_transposed.T)[:, :2]
  embedding_matrix = V_transposed[:2, :].T
  true_orientation_tangential = V_transposed[:2, :] @ true_orientation
  
  meg_ug_ori = unit_gain_orientation(meg_covariance_matrix, reduced_meg_leadfield)
  meg_ag_ori = array_gain_orientation(meg_covariance_matrix, reduced_meg_leadfield)
  meg_ung_ori = unit_noise_gain_orientation(meg_covariance_matrix, reduced_meg_leadfield)
  
  # potentially flip orientation
  if np.inner(meg_ug_ori, true_orientation_tangential) < 0:
    meg_ug_ori *= -1
  if np.inner(meg_ag_ori, true_orientation_tangential) < 0:
    meg_ag_ori *= -1
  if np.inner(meg_ung_ori, true_orientation_tangential) < 0:
    meg_ung_ori *= -1
  
  embedded_meg_ug_ori = embedding_matrix @ meg_ug_ori
  embedded_meg_ag_ori = embedding_matrix @ meg_ag_ori
  embedded_meg_ung_ori = embedding_matrix @ meg_ung_ori
  
  meg_ug_angle = angle(true_orientation_tangential, meg_ug_ori)
  meg_ag_angle = angle(true_orientation_tangential, meg_ag_ori)
  meg_ung_angle = angle(true_orientation_tangential, meg_ung_ori)
  
  ######
  #EMEG
  ######
  
  # strategy : span{V_transposed[:2].T} = 'tangential plane'. Orthogonal direction to this 
  # plane = 'radial direction'. The idea now is to replace the tangential component of the 
  # EEG reconstruction by the MEG reconstruction
  tangential_projection = V_transposed[:2, :].T @ V_transposed[:2, :]
  radial_projection = V_transposed[2:, :].T @ V_transposed[2:, :]
  
  projected_eeg_ug_ori = tangential_projection @ eeg_ug_ori
  projected_eeg_ag_ori = tangential_projection @ eeg_ag_ori
  projected_eeg_ung_ori = tangential_projection @ eeg_ung_ori
  
  eeg_ug_tangential_norm = np.linalg.norm(projected_eeg_ug_ori)
  eeg_ag_tangential_norm = np.linalg.norm(projected_eeg_ag_ori)
  eeg_ung_tangential_norm = np.linalg.norm(projected_eeg_ung_ori)
  
  # since orientations are only determined up to a factor of -1, we could replace the tangential
  # projection of the EEG reconstruction either by + or - the MEG reconstruction. We choose
  # the MEG reconstruction that forms a smaller angle with the tangential projection of the 
  # EEG reconstruction
  
  if np.inner(embedded_meg_ug_ori, projected_eeg_ug_ori) < 0:
    embedded_meg_ug_ori *= -1
  if np.inner(embedded_meg_ag_ori, projected_eeg_ag_ori) < 0:
    embedded_meg_ag_ori *= -1
  if np.inner(embedded_meg_ung_ori, projected_eeg_ung_ori) < 0:
    embedded_meg_ung_ori *= -1
  
  emeg_ug_ori = radial_projection @ eeg_ug_ori + eeg_ug_tangential_norm * embedded_meg_ug_ori
  emeg_ag_ori = radial_projection @ eeg_ag_ori + eeg_ag_tangential_norm * embedded_meg_ag_ori
  emeg_ung_ori = radial_projection @ eeg_ung_ori + eeg_ung_tangential_norm * embedded_meg_ung_ori
  
  if np.inner(emeg_ug_ori, true_orientation) < 0:
    emeg_ug_ori *= -1
  if np.inner(emeg_ag_ori, true_orientation) < 0:
    emeg_ag_ori *= -1
  if np.inner(emeg_ung_ori, true_orientation) < 0:
    emeg_ung_ori *= -1
  
  emeg_ug_angle = angle(emeg_ug_ori, true_orientation)
  emeg_ag_angle = angle(emeg_ag_ori, true_orientation)
  emeg_ung_angle = angle(emeg_ung_ori, true_orientation)
  
  return {
      'eeg_ug_ori' : eeg_ug_ori, 'eeg_ag_ori' : eeg_ag_ori, 'eeg_ung_ori' : eeg_ung_ori,
      'eeg_ug_angle' : eeg_ug_angle, 'eeg_ag_angle' : eeg_ag_angle, 'eeg_ung_angle' : eeg_ung_angle,
      'meg_ug_ori' : meg_ug_ori, 'meg_ag_ori' : meg_ag_ori, 'meg_ung_ori' : meg_ung_ori,
      'meg_ug_angle' : meg_ug_angle, 'meg_ag_angle' : meg_ag_angle, 'meg_ung_angle' : meg_ung_angle,
      'emeg_ug_ori' : emeg_ug_ori, 'emeg_ag_ori' : emeg_ag_ori, 'emeg_ung_ori' : emeg_ung_ori,
      'emeg_ug_angle' : emeg_ug_angle, 'emeg_ag_angle' : emeg_ag_angle, 'emeg_ung_angle' : emeg_ung_angle,
      'eeg_covariance' : eeg_covariance_matrix, 'meg_covariance' : meg_covariance_matrix
  }


# bootstrapped EMEG reconstruction experiment
# Generate a vector of samples of
# d_EEG(t) = q(t) * L_EEG @ ori + n_EEG(t)
# and
# d_MEG(t) = q(t) * L_MEG @ ori + n_MEG(t)
# where n_EEG, n_MEG is gaussian noise, and L_EEG, L_MEG are the EEG and MEG leadfields, and
# q(t) is the source strength. This base signal is the resampled with replacement.
#   params:
#     - true_orientation          :   3 entry array describing the true source orientation
#     - full_eeg_leadfield        :   n_E x 3 array, where n_E is the number of EEG sensors
#     - full_meg_leadfield        :   n_M x 3 array, where n_M is the number of MEG sensors
#     - eeg_noise_level           :   scalar, describing the standard deviation of the EEG noise
#     - meg_noise_level           :   scalar, describing the standard deviation of the MEG noise
#     - fq                        :   scalar, describing the source oscillation frequency
#     - fs                        :   scalar, describing the sampling frequency
#     - regularization            :   scalar, add regularization * (trace(C) / nr_rows_C) * I to the covariance matrices
#     - bootstrapping_repetitions :   integer, number of bootstrapping repetitions
#     - use_nonuniform_noise      :   bool, describing ifa  noise covariance of the form sigma * I
#                                     is used or if a random positive definite matrix is used
#   returns :
#     - dictionary containing median reconstruction errors
def bootstrapped_emeg_reconstruction_experiment(true_orientation, full_eeg_leadfield, full_meg_leadfield, eeg_noise_level, meg_noise_level, fq, fs, nr_samples, regularization, bootstrapping_repetitions):
  
  # initialize rng
  rng = np.random.default_rng()
  
  nr_eeg_sensors = full_eeg_leadfield.shape[0]
  nr_meg_sensors = full_meg_leadfield.shape[0]
  
  normed_eeg_lf = full_eeg_leadfield @ true_orientation
  eeg_lf_norm = np.linalg.norm(normed_eeg_lf)
  normed_eeg_lf /= eeg_lf_norm
  
  normed_meg_lf = full_meg_leadfield @ true_orientation
  meg_lf_norm = np.linalg.norm(normed_meg_lf)
  normed_meg_lf /= meg_lf_norm
  
  # construct noise parameters
  eeg_noise_mean = np.zeros(nr_eeg_sensors)
  meg_noise_mean = np.zeros(nr_meg_sensors)
  eeg_noise_covariance = math.pow(eeg_noise_level, 2) * np.identity(nr_eeg_sensors)
  meg_noise_covariance = math.pow(meg_noise_level, 2) * np.identity(nr_meg_sensors)
  
  # generate all noise samples in one go
  eeg_noise_samples = rng.multivariate_normal(eeg_noise_mean, eeg_noise_covariance, nr_samples)
  meg_noise_samples = rng.multivariate_normal(meg_noise_mean, meg_noise_covariance, nr_samples)
  
  time_course = np.array([source_magnitude(i, fq, fs) for i in range(nr_samples)]).reshape((nr_samples, 1))
  
  original_eeg_data_matrix = np.repeat(time_course, nr_eeg_sensors, axis = 1) * np.tile(normed_eeg_lf, (nr_samples, 1)) + eeg_noise_samples
  original_meg_data_matrix = np.repeat(time_course, nr_meg_sensors, axis = 1) * np.tile(normed_meg_lf, (nr_samples, 1)) + meg_noise_samples
  
  eeg_ug_angles = []
  eeg_ag_angles = []
  eeg_ung_angles = []
  
  meg_ug_angles = []
  meg_ag_angles = []
  meg_ung_angles = []
  
  emeg_ug_angles = []
  emeg_ag_angles = []
  emeg_ung_angles = []
  
  for i in range(bootstrapping_repetitions):
    # draw samples with replacement
    random_indices = rng.integers(0, nr_samples, nr_samples)
    eeg_data_matrix = original_eeg_data_matrix[random_indices]
    meg_data_matrix = original_meg_data_matrix[random_indices]
    
    eeg_covariance_matrix = (eeg_data_matrix.T @ eeg_data_matrix) / nr_samples
    eeg_covariance_matrix += regularization * (np.trace(eeg_covariance_matrix) / nr_eeg_sensors) * np.identity(nr_eeg_sensors)
    
    meg_covariance_matrix = (meg_data_matrix.T @ meg_data_matrix) / nr_samples
    meg_covariance_matrix += regularization * (np.trace(meg_covariance_matrix) / nr_meg_sensors) * np.identity(nr_meg_sensors)
    
    ##############
    # perform orientation reconstruction
    ##############
    
    ######
    #EEG
    ######
    eeg_ug_ori = unit_gain_orientation(eeg_covariance_matrix, full_eeg_leadfield)
    eeg_ag_ori = array_gain_orientation(eeg_covariance_matrix, full_eeg_leadfield)
    eeg_ung_ori = unit_noise_gain_orientation(eeg_covariance_matrix, full_eeg_leadfield)
    
    # potentially flip orientation
    if np.inner(eeg_ug_ori, true_orientation) < 0:
      eeg_ug_ori *= -1
    if np.inner(eeg_ag_ori, true_orientation) < 0:
      eeg_ag_ori *= -1
    if np.inner(eeg_ung_ori, true_orientation) < 0:
      eeg_ung_ori *= -1
    
    eeg_ug_angles.append(angle(true_orientation, eeg_ug_ori))
    eeg_ag_angles.append(angle(true_orientation, eeg_ag_ori))
    eeg_ung_angles.append(angle(true_orientation, eeg_ung_ori))
    
    ######
    #MEG
    ######
    U, S, V_transposed = np.linalg.svd(full_meg_leadfield)
    reduced_meg_leadfield = full_meg_leadfield @ (V_transposed.T)[:, :2]
    embedding_matrix = V_transposed[:2, :].T
    true_orientation_tangential = V_transposed[:2, :] @ true_orientation
    
    meg_ug_ori = unit_gain_orientation(meg_covariance_matrix, reduced_meg_leadfield)
    meg_ag_ori = array_gain_orientation(meg_covariance_matrix, reduced_meg_leadfield)
    meg_ung_ori = unit_noise_gain_orientation(meg_covariance_matrix, reduced_meg_leadfield)
    
    # potentially flip orientation
    if np.inner(meg_ug_ori, true_orientation_tangential) < 0:
      meg_ug_ori *= -1
    if np.inner(meg_ag_ori, true_orientation_tangential) < 0:
      meg_ag_ori *= -1
    if np.inner(meg_ung_ori, true_orientation_tangential) < 0:
      meg_ung_ori *= -1
    
    embedded_meg_ug_ori = embedding_matrix @ meg_ug_ori
    embedded_meg_ag_ori = embedding_matrix @ meg_ag_ori
    embedded_meg_ung_ori = embedding_matrix @ meg_ung_ori
    
    meg_ug_angles.append(angle(true_orientation_tangential, meg_ug_ori))
    meg_ag_angles.append(angle(true_orientation_tangential, meg_ag_ori))
    meg_ung_angles.append(angle(true_orientation_tangential, meg_ung_ori))
    
    ######
    #EMEG
    ######
    
    # strategy : span{V_transposed[:2].T} = 'tangential plane'. Orthogonal direction to this 
    # plane = 'radial direction'. The idea now is to replace the tangential component of the 
    # EEG reconstruction by the MEG reconstruction
    tangential_projection = V_transposed[:2, :].T @ V_transposed[:2, :]
    radial_projection = V_transposed[2:, :].T @ V_transposed[2:, :]
    
    projected_eeg_ug_ori = tangential_projection @ eeg_ug_ori
    projected_eeg_ag_ori = tangential_projection @ eeg_ag_ori
    projected_eeg_ung_ori = tangential_projection @ eeg_ung_ori
    
    eeg_ug_tangential_norm = np.linalg.norm(projected_eeg_ug_ori)
    eeg_ag_tangential_norm = np.linalg.norm(projected_eeg_ag_ori)
    eeg_ung_tangential_norm = np.linalg.norm(projected_eeg_ung_ori)
    
    # since orientations are only determined up to a factor of -1, we could replace the tangential
    # projection of the EEG reconstruction either by + or - the MEG reconstruction. We choose
    # the MEG reconstruction that forms a smaller angle with the tangential projection of the 
    # EEG reconstruction
    
    if np.inner(embedded_meg_ug_ori, projected_eeg_ug_ori) < 0:
      embedded_meg_ug_ori *= -1
    if np.inner(embedded_meg_ag_ori, projected_eeg_ag_ori) < 0:
      embedded_meg_ag_ori *= -1
    if np.inner(embedded_meg_ung_ori, projected_eeg_ung_ori) < 0:
      embedded_meg_ung_ori *= -1
    
    emeg_ug_ori = radial_projection @ eeg_ug_ori + eeg_ug_tangential_norm * embedded_meg_ug_ori
    emeg_ag_ori = radial_projection @ eeg_ag_ori + eeg_ag_tangential_norm * embedded_meg_ag_ori
    emeg_ung_ori = radial_projection @ eeg_ung_ori + eeg_ung_tangential_norm * embedded_meg_ung_ori
    
    if np.inner(emeg_ug_ori, true_orientation) < 0:
      emeg_ug_ori *= -1
    if np.inner(emeg_ag_ori, true_orientation) < 0:
      emeg_ag_ori *= -1
    if np.inner(emeg_ung_ori, true_orientation) < 0:
      emeg_ung_ori *= -1
    
    emeg_ug_angles.append(angle(emeg_ug_ori, true_orientation))
    emeg_ag_angles.append(angle(emeg_ag_ori, true_orientation))
    emeg_ung_angles.append(angle(emeg_ung_ori, true_orientation))
  
  return {
      'median_eeg_ug_angle' : statistics.median(eeg_ug_angles), 'median_eeg_ag_angle' : statistics.median(eeg_ag_angles), 'median_eeg_ung_angle' : statistics.median(eeg_ung_angles),
      'median_meg_ug_angle' : statistics.median(meg_ug_angles), 'median_meg_ag_angle' : statistics.median(meg_ag_angles), 'median_meg_ung_angle' : statistics.median(meg_ung_angles),
      'median_emeg_ug_angle' : statistics.median(emeg_ug_angles), 'median_emeg_ag_angle' : statistics.median(emeg_ag_angles), 'median_emeg_ung_angle' : statistics.median(emeg_ung_angles),
  }
